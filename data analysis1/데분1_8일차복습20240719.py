# -*- coding: utf-8 -*-
"""데분1_8일차.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H_PCnJIuEa6z7ycUv1tmn-XjbOZfvz5S
"""

#문자열 메소드
#.format()

#문자 지정
print("내가 좋아하는 {}가 {}상을 받았대".format('유다빈밴드', '멜론어워드'))
print()

#문자열 정렬
print("'{:>10d}'".format(1234)) #10칸생성. 기본형: {:>10d}
print("[{:>10s}]".format("안녕")) #{:(사용할 정렬방법, 칸수,형식지정자)}
print("10칸짜리 폭 오른쪽 정렬: '{:>10d}'".format(123))
print("10칸짜리 폭 왼쪽 정렬: '{:<10d}'".format(123))
print("10칸짜리 폭 가운데 정렬: '{:^10d}'".format(123))
print("10칸짜리 폭 오른쪽 정렬: '{:>10.2f}'".format(3.14)) #실수형도 가능 형식지정자앞에 소수점 정해줄수도 있음

print()
#남은 공백칸에 원하는 문자/숫자 넣기
print("10자리 왼쪽 정렬: '{:*<10d}'".format(123))#공백안에 *문구가 들어가서 채워짐
print("10자리 오른쪽 정렬: '{:@>10d}".format(123)) #공백안에 @가 들어가서 채워짐
print("10자리 가운데 정렬: '{:%^10s}'".format("안녕")) #문자열도 동일함

#문자열 메소드:문자열에서 사용할 수 있는 메소드

#.count():지정된 문자열안에서 원하는 특정 문자가 몇개있는지 찾아줌
sok = "내가 그린 기린 그림은 목 긴 기린그림이고, 네가 그린 기린 그림은 목 짧은 기린 그림이다"
print(sok,type(sok))

print(sok.count('그림')) #그림이라는 단어 총 4번 등장
print(sok.count('기린'))
print(sok.count('so'))#문자열 안에 없는 단어 넣어도 오류나지 않음. 없다고 알려줌

data = "best of Best"
print(data.count('best')) #대소문자 구분해서 찾아줌. 1번있기때문에 1번
print(data.count('best,5'))
#인덱스 번호를 지정해준 경우. 인덱스 번호상 5번째부터 'best'단어를 찾아달라고 한것인데
#5번째부터는 해당 단어가 없기때문에 0이라고 반환한것.
print(data.count('Best',-7))
#마이너스 인덱스 번호로도 사용이 가능하며, 기본인덱스나 마이너스 인덱스 모두
#해당 지점부터 오른쪽으로 이동하며 해당 글자를 찾아줌
print()


#.find()
print(data.find('best')) #bset글자가 가장 첫번째부터 나오기때문에 0번째인 0을 반환
print(data.find('of'))
print(data.find('Best',-5)) #인덱스로 탐색범위를 지정하더라도 값이 크게 달라지진않음.
#탐색위치를 설정하더라도 그 안에서 인덱스가 다시0이 되는것이 아니라 인덱스 번호는 달리지않기때문
print(data.find('of',-4)) #마이너스 인덱스로 지정해도 몇번째 있는지는 나오지만 마이너스로 인덱스번호를
#세기 시작했기때문에 마이너스 인덱스 번호로 출력됨
#인덱스 지정범위부터 오른쪽으로 이동하며 찾는데 지정된 범위안에서는 값이 없기때문에 -1반환
print(data.find('as'))#아예 없는 단어 입력해도 오류나지 않고 -1반환
print()

#rfind()
#기능과 사용법 모두 .find()와 동일하지만 오른쪽에서 왼쪽으로 찾아줌.
#마찬가지로 제일먼저 나온 문자의 인덱스를 반환
data='best of best'
print(data.rfind('best')) #오른쪽에서 왼쪽으로 찾아준다고 하더라도 인덱스위치는 변하지 않기때문에
#8이 나오지만, 찾는 위치가 오른쪽기준에서 제일 먼저나오는 두번째 best를 찾아준것
print(data.rfind('best',-7))#지정위치 문자찾는건 오른쪽으로 흐르기때문에 동일하게 8번째 나옴
print(data.rfind('as')) #.rfind도 동일하게 찾는문자가 없다면 -1을 반환
print()

#.index
#.find, .rfind와 동일한 기능을 하지만 찾는 문자가없다면 오류가 남
# print(data.index('as')) #as라는 단어가 없기때문에 오류가남
print(data.index('best',5))

#문자열 메소드

#대소문자 변환메소드
data='best of best'

print(data.upper()) #대문자
print(data.lower()) #소문자
print(data.capitalize())#capitalize는 첫글자만 대문자로 반환하며 나머지는 소문자로 반환

#문자열 메소드
#,join
#반복가능 객체 => 시퀀즈 자료형(문자열)

li = ['p','y','t','h','o','n']
print(li,type(li))
tu1= ('1','2','3','4','5')
se1={'1','2','3','4','5'}
di={'밴드' :'유다빈', '발라드' :'선우정아', '아이돌' :'엔믹스'}

print(''.join(li),type(''.join(li))) #python이라는 하나의 문자열로 합쳐짐
#리스트의 요소를 하나의 문자열로 반환해준것. 때문에 자료형도 리스트가 아니라 str로 출력
print('@'.join(li),type('@'.join(li))) #마찬가지로 반복객체요소 사이에 특정 @문자를 넣어서 문자로 출력
print('-'.join(tu1)) #반복가능 객체에 들어가야할 값은 문자여야함 #숫자면 오류남
print('*'.join(se1)) #세트도 마찬가지. 숫자안됨. 순서상관X
print('^^'.join(di)) #딕셔너리는 key값만 모아서 출력됨

#문자열 메소드
#.split
#공백기준으로 단어 나눠주기
str1="Life is too short"
print(str1,type(str1))

print(str1.split(),type(str1.split())) #공백기준으로 단어를 나눠서 리스트안에 넣어줌
print()

#특정문자 기준으로 단어나눠 출력하기
print(str1.split('o'),type(str1.split('o')))
#'o'기준으로 단어가 나눠졌기때문에 too의 o와 shot의 o를 기준으로 단어가 나뉜것
#중복으로 단어가 있으면 전부다 기준점으로 성립이됨
#기준으로 선정된 문자는 출력되지 않음.
print()


#.repalce()
#문자열에서 일부 문자열을 바꾼후 그 결과를 반환하는 메소드
#대상과 바꿀대상으로 인수를 2개를 입력해주어야함. 첫번째 대상을 두번째로 바꾸겠다는 의미
print(str1.replace('short','long'))#shot이 long으로 변경
print(str1.replace('Life','study time'))
print()

#.isdigit()

#.isdigit()
#문자열이 숫자로만 이루어져있는지 확인.
#문자가 하나라도 있다면 False반환 전부 숫자라면 True반환

print('10'.isdigit()) #어떤식으로 사용하나
# print(str.isdigit("10")) #결과는 동일함

# li=['1','2','3','4','5']
# print(li.isdigit())
#리스트 사용불가! 반복객체말고 '문자열'을 보는것

print('20491'.isdigit())
print('2353a'.isdigit()) #문자열a가 한개 있기때문에 False반환
print('-12'.isdigit())#-마이너스 문자열로 인식하여 False반환
print('1.23'.isdigit()) #소수점.도 문자열로 인식하여 False반환
print()


#.strip()
#불필요한 문자를 제거해주는 메소드
#.strip() : 양쪽의 불필요한 문자 제거
#.lstrip() : 왼쪽의 불필요한 문자 제거
#.rstrip() : 오른쪽의 불필요한 문자 제거
#중간에 있는 문자는 제거할 수 없음!

str="*******1***2**3******"
print(str.strip('*')) #strip안에 지정한 문자를 지워줌. #양쪽에 있는것만 지워지고 중간은 제거안됨
print(str.lstrip('*'))
print(str.rstrip('*'))

#<사용자 정의 함수>
#welcome 함수 정의 : 문자열 출력(return)

#함수 정의/ 함수를 만들어주기만 한것(선언)이기때문에 호출해야 사용가능
def welcome():
  print('hello')
  print('안녕!ㅎㅎ')

#함수 호출
#함수명()
welcome() #함수명 옆에 소괄호 필수
welcome() #몇번이고 계속 호출 가능!

#특정값에 +10을 하는 함수
#add

#add 함수 정의

def add(num):
  result = num+10
  return result

# add() 이렇게 출력하면 안되는이유!
#함수안에 매개변수를 정의해줬기때문에 num안에 들어갈 값을 함수()괄호안에다 적어주어야함
#add(5) 이렇게도 출력하면 안되는이유!
#코렙미리보기 기능때문에 보여지지만 return값 안에 프린트 문을 따로 넣어놓지 않았기때문에
#이렇게 출력하면 안됨. 위의 welcome의 경우에는 return값이 없고, 처리기능 자체에 출력문을 넣어놨기때문에가능하지만
#add()함수는 따로 출력문을 넣지않아서 print()를 사용하여 함수를 호출해야함.

print(add(5))
#이렇게 출력하는 것이 가장 올바른 방법

#디폴트 매개변수 만들기
#greet()함수
def greet(str1,str2):
  print(str1)
  print(str2)

#greet()함수 호출
#이미 처리할 기능에 출력을 넣어놨기때문에 그냥 함수명()으로 출력가능
#전달해줄 인수와 그 인수를 저장할 매개변수가 존재하기때문에 매개변수를 입력해주어함
greet('오늘도','좋은하루보내') #괄호안에 적은 순서대로 매개변수 안에 들어감
# greet('안녕') #매개변수가 2개인데 1개만 전달했기때문에 오류
#이런경우 디폴트를 만들어주면 됨

#디폴트 매개변수 만들기2_숫자 4개를 더하는 함수정의하기

def add(num1,num2,num3,num4=10):
  result=num1+num2+num3+num4
  return result

print(add(10,10,10,10)) #정의된 매개변수 4개, 입력된 인수4개 이기때문에 오류나지 않음
# print(add(1,23,4))#3개만 입력했기때문에 오류
#여기서 num4에 디폴트값을 설정/매개변수 대입연산자 쓰고 값 써주기
print(add(10,10,10))#num4에 디폴트값인 10이 들어갔기때문에 인수를 3개만 입력해주어도 오류나지 않음
print(add(10,10,10,20))#이미 지정된 디폴트값에 인수로 또 다른 값을 정의해도 오류안남
#디폴트의 값이 그냥 저장되어있는거지 사용자가 따로 저장해줄수 있음


# def add(num1,num2,num3=10,num4):
#   result=num1+num2+num3+num4
#   return result
#디폴트 함수는 맨 끝부터 만들어 줄 수 있기때문에 중간에있는 num3을 바로 디폴트 만들어줄 수 없음
# def add1(num1,num2,num3=20,num4=10): 맨끝인 num4부터 매개변수를 만들어주었기때문에 오류나지않으며 인수 2개만 입력해도 됨

#가변 매개변수 만들기
#가변매개변수: 몇개의 인수를 전달할지, 즉 몇개의 매개변수를 사용할지 모르는 상태일때 사용
#가변 매개변수 만드는 방법: *가변매개변수 명

def show(*args): #show라는 함수안에 args라는 가변 매개변수를 만들어준 것
  print(f"args: {args}")
  print(f"args: {type(args)}")

show(1,2,3,4) #인수 4개가 튜플로 묶여서 출력
show('안녕') #어차피 값이 튜플이기때문에 자료형 상관없고, 갯수도 상관없음

# for i in show(1,2,3,4):
#   print(i)
#결과를 튜플로 반환해주긴 하지만 바로 반복문으로 사용은 안됨
#하지만 함수 안에 반복문을 넣어서 출력하는 것은 가능함
print()

def show(*args): #show라는 함수안에 args라는 가변 매개변수를 만들어준 것
  print(f"args: {args}")
  print(f"args: {type(args)}")
  for i in args:
    print(i)

show(10,9,8,7,6,5) #반복문안에 for문을 넣어서 함수를 출력하면 자동으로 언패킹되어 값이 출력될 수 있도록 만든것

#경우에 따른 함수 호출 방법

#1)매개변수 X, 리턴값 X
#함수명()

def welcome():
  print("오늘도 화이팅")

welcome()#매개변수가 없으니 인수도 따로 적어줄것이 없는것

#2) 매개변수 O, 리턴값X
#print_name함수 정의

def print_name(name):
  print(name)#따로 리턴값이 없기때문에 함수정의할때 인수만 적으면 바로 출력되도록 기능에 출력문을 넣음

print_name('홍길동') #안에 출력문이 이미 있기때문에 따로 출력문을 적어줄 필요는 없지만
#매개변수가 있기때문에 함수 괄호안에 인수를 적어주면 됨
print()


def print_info(name,age,gender='여성'):
  print(name, age,gender)

print_info('홍길동',25,'여성')

#매개변수 X, 리턴값 O

def getMyname():
  name =  "짱구" #매개변수가 없는대신 함수안에 변수를 따로 만들고 그 변수를 리턴값으로 지정
  return name   #매개변수는 직접 전달해줘야할 인수가 있다면 매개변수없이 변수만 만들면 따로 값 전달 할 필요없음

print(getMyname()) #리턴값의 경우 따로 반환받을 리턴값이 있다는건 print문으로 출력을 해야함.
#리턴값이 있는 함수의 결과는 값처럼 사용이 가능하다!!!

print(getMyname()+"입니다") #리턴값으로 반환받은것이 문자라면 문자열 연산자로 사용가능

def getnumber():
  num=10
  return num

print(getnumber()) #숫자 10 출력
print(getnumber()+10) #값처럼 연산가능
num_f=getnumber() #함수 자체를 변수안에 넣어서
print(num_f+10) #그 변수를 가지고 값처럼 사용도 가능함!!

#매개변수o, 리턴값o

def addNum(num1,num2):  #매개변수 존재
  return num1+num2      #리턴값도 존재

print(addNum(10,10)) #print(함수명(전달할 인수))
result=addNum(10,10)
print(result)

#리턴값이 있는 함수의 리턴값은 값처럼 사용가능!
print(result*10)
print(addNum(10,10)*100)

print()

#함수안에 컬렉션 넣기

def maxlist(li):
  return max(li)  #리턴값으로 어떤걸 전달해줄지는 모르지만 전달받은 인수들 중에서 가장 큰 값을 반환해줘

# print(maxlist(1,2,3,4))
# print(maxlist(1))
#↑위의 두값이 안되는 이유
#max는 튜플과 리스트에서 사용되는 함수로, 무언가의 묶음안에서 가장 큰값을 찾아달라는 것
#그렇기때문에 하나만 입력해선 안되며, 개별로 여러값을 입력했다 하더라도 콤마로 구분된 값이므로 개별이기때문에
#비교하여 가장 큰값만 도출해 낼 수 없음

print(maxlist((1,2,3,4,4))) #어떤 묶음인지 정의해준적 없으므로 튜플가능
print(maxlist([1,2,3,4,5])) #어떤 묶음인지 정의해준적 없으므로 리스트가능

#return값의 사용
#1) 함수의 결과를 알려줘야 할때
#2) 함수를 종료시킬때

def exit():
  print("return문은")
  return
  print("함수종료를 의미하기도 합니다!")

#함수 호출
exit()
#return뒤에 반환받을 값을 정해주지 않으면 반문에서 break가 하는 역할과 비슷함

#<실습문제1>
#1)add()함수 정의 -> 2개의 정수를 입력받아 입력받은 숫자를 합하는 기능
#2)매개변수 o , returnX

def add(num1=int(input("첫번째 정수입력: ")),num2=int(input("두번째 정수를 입력: "))):
  print(num1+num2)

add()

#<실습문제1>_쌤 정답
#1)add()함수 정의 -> 2개의 정수를 입력받아 입력받은 숫자를 합하는 기능
#2)매개변수 o , returnX

def add(num1,num2):
  print(num1+num2)

number1=int(input("첫번째 정수 입력: "))
number2=int(input("두번째 정수 입력: "))

add(number1,number2)

#<실습문제2>
# sub()함수 정의 -> 함수 안에서 2개의 변수 선언(정수 저장)2개의 정수 뺄셈결과 출력(큰수-작은수)
#매개변수 x 리턴o

def sub():
  num1=10
  num2=100
  return num1-num2 if num1>num2 else num2-num1

print(sub())

#<실습문제3>
# mul()함수 정의 ->2개의 정수를 입력받아 2개의 숫자를 곱해주는 기능
#매개변수 O 리턴O

def mul(num1=int(input("1번째 정수입력: ")),num2=int(input("2번째 정수입력"))):
  result=num1*num2
  return result

print(mul())

print()

print(f"mul함수의 답은: {mul()}입니다")

#<실습문제3>
# mul()함수 정의 ->2개의 정수를 입력받아 2개의 숫자를 곱해주는 기능
#매개변수 O 리턴O

def mul(num1,num2):
  result=num1*num2
  return result

num11=int(input("첫번째 정수 입력: "))
num22=int(input("두번째 정수 입력: "))

print(f"{num11}x{num22}는 mul()함수의 답: {mul(num11,num22)}")

#<실습문제2>
# 문자열을 뒤집어서 출력하는 함수 정의
#문자열을 입력받아, 입력받는 문자열을 거꾸로 출력하는 함수 정의하기
#함수 호출


def str(str1=str(input("문자를 입력해주세요: "))):
  result=str1[::-1]
  return result

print(str())

#<실습문제2>
# 문자열을 뒤집어서 출력하는 함수 정의
#문자열을 입력받아, 입력받는 문자열을 거꾸로 출력하는 함수 정의하기
#함수 호출

def str(str1):
  result=str1[::-1]
  return result

str2=input("문자를 입력해주세요")

print(str(str2))
