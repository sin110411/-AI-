# -*- coding: utf-8 -*-
"""데분1_9일차_복습20240720.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IUbTUZfo6dLEX6AKk-l4zdu6qe8lT0dw
"""

#전역변수와 지역변수

value =100 #전역변수

def change_value():
  value=200 #지역변수 (전역변수와는 상관x)
  print(f"value={value}")

change_value() #지역변수는 함수 호출시에만 사용되는 일회용 변수이기 때문에 전역변수의 값을 바꾸지 못함.

print(f"value={value}")#함수 밖에서 정의되었고 함수를 호출한것이 아니기때문에 전역변수로 만들어준 값이 나온것

#함수내부에서 전역변수 사용하기
#global: 함수 내부에서 전역변수를 가져오는 키워드

value1=200 #전역변수 만들어줌

def change_value():
  global value1 #global 변수 : 전역변수로 사용하겠다는 뜻
  print(f"value1={value1}")

change_value() #전역변수 값 100으로 출력
print(value1) #함수 밖으로 나가도 값이 달라지지 않고 똑같음

#<global키워드 실습>

band_name = '유다빈 밴드'

def change_name():
  global band_name
  print(band_name)

change_name()
print(band_name)

print()

#함수 호출할때마다 num_stamp의 + 1씩 증가시키는 함수만들기

num=0

def num_stamp():
  global num  #global 키워드 옆에는 변수 이름만 정의!
  num+=1      #global 키워드로 가져온 전역함수 활용은 그 밑에다 할것!
  return num

print(num_stamp())

#매개변수에 전역변수에 저장된값 전달하여 사용하가
#사용 권장사항!

num_stamp=0 #전역변수

def stamp(num_stamp): #매개변수(지역변수) #위에 선언된 애랑 다른애
  num_stamp+=1
  return num_stamp

num_stamp=stamp(num_stamp) #전역변수를 재정의하면서 함수값안에 그전에 정의되었던 변수의 0값을 넣어줌
print(num_stamp)#변수가 함수반환값으로 재정의 되면서 변수만 출력해주면 됨
#함수의 리턴값이 변수의 값이 되면서 변수의 값이 변함

#표준 모듈 사용하기
#모듈 불러오는 방법
# import 파일명 : import 뒤에있는 파일의 모든것을 사용하겠다
# from 파일명 import * : from뒤에있는 파일의 모든것(*)을 사용하겠다

#함수 사용법
#파일명.함수
#.(~의.~안에 라는뜻)

import random #랜덤은 난수와 관련된 여러함수를 모아놓은 파일
#random의 종류
#1) randint(a,b) : a이상 b이하의 숫자중에서 랜덤한 정수를 return
print(random.randint(1,10)) #random파일에서 randint라는 함수를 사용하겠다는 뜻

#2)randrange()
#randrange(a) :0~a-1 사이의 숫자중 랜덤한 값을 return
#randrnage(a,b)
#randrange(a,b,c)

print(random.randrange(10)) #0~9사이의 값 랜덤 추출
print(random.randrange(10,21))#10~20사이의 값 랜덤 추출
print(random.randrange(0,11,2))#0~10사이의 값 추출하는데 2씩 건너뛰어서 추출

print()

#choice(시퀀스 자료형): 시퀀스 자료형 값 중 하나만 추출
print(random.choice([1,2,3,4,5,6,7,8,9,10]))
print(random.choice(('안녕',3.13,2,True)))

#sample(시퀀스 자료형): choice와 기능 비슷. sample은 해당 시퀀스에서 뽑을 자료형의 갯수를 지정해줄 수 있음
print(random.sample(['봄','여름','가을','겨울'],2))

#모듈에서 특정함수만 import하는 법
#위의 방법처럼 모듈을 전체 불러놓고 함수를 쓰다보면 성능이 느려질 수 있음
#from 파일명 import 함수명
#from 파일명 import 함수명1, 함수명2, 함수명3...이렇게 여러함수 동시 불러오는 것도 가능

from random import randint, randrange #random함수 안에서 가져올 함수적기
#위의 방법처럼 모듈을 전체 불러놓고 쓰려면 모듈안의 함수를 쓸때마다 파일명.함수의 형태로
#일일히 파일명을 붙여주어야하지만 사용할 함수만 가져오면 함수명만 기입하여 사용이 가능함

#randint와 randrange는 불러와준 함수이기때문에 사용가능
print(randint(0,10)) #앞에 파일명 없는데도 사용가능
print(randrange(0,10))

#불러온적이 없는 함수이기때문에 사용이 불가능
# print(choice([1,2,3,4]))
# print(sample(['밴드','락','발라드']))

#다른 종류의 파일명과 함수들

#1)time : 시간과 관련된 함수와 기능을 모아놓은 모듈
import time

#time의 함수
#1)sleep(정수): 입력한 정수=초. 해당 초만큼 실행을 멈춰주는 함수
time.sleep(3) #3초 뒤에 실행
print('3초 뒤에 전하는 인사')

#2)time(): 1970년 1월 1일 0시0분 0초부터 현재까지 흐른 초를 나타낸 값
print(time.time())

#파일에 별칭만들기
import matplotlib.pyplot as plt
plt.plot([1,2,3,4],['a','b','c','d'])
plt.show()

#클래스 선언하기

class Person:  #클래스 선언
  def get_name(self,name):
    self.name=name #self.name(데이터 속성)=name(매개변수)

  def get_age(self,age):
    self.age=age

  def introduce(self):
    print(f"안녕하세요? 제 이름은 {self.name}입니다")
    print(f"제 나이는 {self.age}살 이에요")

#객체화 작업
#객체명 = 클래스명()

pr1=Person()   #객체를 구별하기위해 self라는 것을 만들었고 객체명을 pr1이라고 지정
print(pr1,type(pr1))  #pr1이라는 객체가 지정이 되어서 클래스안에 만들어두었던 변수를 통해
#pr1이라는 객체에 대한 특징(값)을 넣어주는 작업이 필요함


#데이터 속성에 값 대입   (붕어빵 '팥'넣는 작업)
pr1.name='짱구'
#클래스에서 get_name이라는 메소드를 만들어줬지만 self.name이라는 객체 구별 변수를 만들어주었기때문에
#변수로 값을 넣어주어도 됨
print(pr1.name)
pr1.age=25
#마찬가지로 get_age라는 메소드를 만들었지만 self.age객체 구별 변수를 미리 만들어두었기때문에
#변수로 값을 넣어주어도 됨
print(pr1.age)

#메소드 호출
pr1.introduce()
#introduce의 메소드는 매개변수도 없고, 출력문만 있기때문에 굳이 pritn()로 출력할 필요없음

print()


#Person class로 다른 객체 선언하기

#객체화
#객체명=클래스명()

pr2=Person()

#데이터 속성값에 값 넣기
#메소드명을 통해서 넣기

pr2.get_name('유리')
print(pr2.name)
# print(pr2)이건 그냥 객체이름일 뿐. 객체에 값이 들어갔는지 확인하려 self변수의 형태로 출력해야함

pr2.get_age(25)
print(pr2.age)

#메소드 출력하기
pr2.introduce()

#pr1과 pr2모두 같은 calss에서 만들어졌고 형태모두 같지만 각각 가지고 있는 속성값(팥, 슈크림)이 다름
#pr1의 속성값이 수정된다거나 pr1이 사라진다고해서 pr2에 아무런 영향을 주지 않음
#서로 각각 다른 객체
#<0x7c7d9fae8670> => 메모리 주소값

#<실습>
#Person class를 이용하여 4개의 객체 만들고, 값대입하고, 최종 형태로 출력까지 하기

#객체화
p1=Person()
p2=Person()
p3=Person()
p4=Person()

#데이터 속성값 넣기
p1.name='유다빈'
p1.age=26

p2.name='문상훈'
p2.age=32

p3.get_name('김한주')
p3.get_age(29)

p4.get_name('정우')
p4.get_age(27)

#최종형태 출력문
p1.introduce()
p2.introduce()
p3.introduce()
p4.introduce()

#생성자 만들기
#객체를 선언할때 처음으로 반드시 호출되는 메소드(객체화하는 바로 그 순간에 실행되는 메소드)
#__init__의 형태

#<생성자가 추가된 Person>클래스의 정의

class Person:
  def __init__(self,name, age):
    self.name=name
    self.age=age

  def introduce(self):
    print(f"안녕하세요? 저는 {self.name}입니다")
    print(f"제 나이는 {self.age}살 입니다")

#생성자의 객체화 작업
p1=Person('둘리',14) #객체화 하면서 데이터의 값을 대입함
#원래는 객체화 따로 하고 그 객체화된걸 가지고 데이터의 값을 넣어줬었음
#생성자는 객체화를 하는 바로 그 순간에 처음으로 호출되는 메소드 이끼때문에 객체화를 하면서 동시에 값넣기가 가능하여
#기존 생성자가 없는 class보다 조금 더 편리해졌음
#생성자를 객체화할때 클래스명 안에다가 내가 넣어주어야할 인수들의 값을 순서대로 넣어주면 됨
p2=Person('도우너',8)

p1.introduce()
p2.introduce()

#<실습>
#클래스 선언
#클래스 명: Player()
#데이터 속성: 이름(name),나이(age),직업(job)
#생성자 1개 (이름, 나이, 직업), 출력 메소드 1개 (이름,나이, 직업)

#객체 2개
#축구 선수, 야구선수
#2개의 객체 각가 출력메소드 호출

class Player:
  def __init__(self,name,age,job):
    self.name=name
    self.age=age
    self.job=job

  def Player_info(self):
    print(f"이름: {self.name}")
    print(f"나이: {self.age}")
    print(f"직업: {self.job}")


player1=Player('손흥민',34,'축구선수')
player2=Player('류현진',45,'야구선수')

player1.Player_info()
player2.Player_info()
