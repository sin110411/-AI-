# -*- coding: utf-8 -*-
"""데분1_3일차 복습.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10jFMO1rqIP3_z9uUzwTNjCv3qghdBgjI
"""

#연산자 출력순서

#연산자는 정해져있는 우선출력 순서가있음
#1)최우선 연산자
#2)단항연산자
#3)산술연산자
#4)쉬프트 연산자
#5)관계연산자
#6)논리연산자
#7)삼항연산자
#8)대입/복합대입연산자

#최우선 연산자 : 가장 먼저 계산하는것
#최우선 연산자 종류: (),[]

print(10-3*10) #괄호없이 계산하면 -20이 나옴 *먼저 계산되었기때문
print((10-3)*10) #괄호로 묶으면 60이 나옴. 괄호안에 있는게 먼저 계산

#단항 연산자 : 한개의 항을 사용한 연산자
#단항 연산자 종류: +양수, -음수

print(+10,type(+10)) #+10은 그냥 기본 10
print(-10,type(-10)) #-10은 -10
print(+3.14,type(+3.14)) #실수형도 똑같이 그냥 기본 3.14
print(-3.14,type(-3.14)) #-3.14

# 산술연산자 : +(덧셈),-(마이너스),/(나누기),//(몫),%(나머지),**(거듭제곱)

#+덧셈
num1 = 10
num2 = 20
print(num1+num2,type(num1+num2)) #정수+정수=정수형

#-뺄셈
print(num1-num2,type(num1-num2)) #정수-정수=정수
print(num1-4.0,type(num1-4.0)) #6.0출력하고 자료형 float. 정수-실수=실수!
print(num1+10.0,type(num1+10.0)) #정수+실수=실수

#*곱하기
print(num1*num2,type(num1*num2)) #정수 * 정수 = 정수
print(num1*10.0,type(num1*10.0)) #정수 * 실수 = 실수

#/ 나누기
print(num2/num1,type(num2/num1))#나누기의 경우 정수/정수 해도 결과가무조건 실수로 출력!
#int/int=float(값이 딱 떨어져도 무조건 실수로 출력)
print(3.14/num1,type(3.14/num1)) #정수 / 실수 가능
print(num1/3.14,type(num1/3.14)) #실수/ 정수 가능

#/나누기 연산자 에러
# print(num1/0,type(num1/0))  #나누기의 분모자리에는 0이 들어갈 수 없기때문에
#0 이 들어가면 무조건 에러가남
# print(3.14/0,type(3.14/0)) #소수 마찬가지로 0이들어가면 에러
# print(0/3.14,type(0/3.14))

#//몫
print(num2//num1,type(num2//num1)) #20나누기 10은 2이기때문에 몫인 2가 출력되며
#20/10의 몫은 딱 2로 떨어지므로 소수점이 아니여서 정수출력
print(10//3,type(10/3)) # 10/3 = 3.3333333....에서 뒤에 소수점자리 빼고 3만 출력함
#10/3은 결론적으로는 3.3333인 소수이므로 float인 실수형 출력

#% 나머지
num3 = 10
num4 = 3
print(num3%num4,type(num3%num4)) # 1출력 나머지를 가져오며 정수형!

#%나머지 연산자로 구별하는 짝수, 홀수!
#짝수 : 2로 나누면 나머지가 무조건 0
#홀수  :2로 나누면 나머지가 무조건 1
print(10%2,type(10%2)) #정수형이면서 나머지 0
print(11%2,type(11%2)) #정수형이면서 나머지 1

#%나머지 연산자로 배수 구분하기
#3의 배수를 구할때 3으로나누면 나머지 0, 4의 배수를 구할때 4로 나누면 나머지 0
print(9%3,type(9%3)) #3은 9의 배수. 나머지 0 출력
print(10%2,type(10%2)) #10은 짝수이면서 2의배수. 나머지 0출력

#**거듭제곱
print(10**2,type(10**2)) #10*10=100 정수형 출력
print(num2**10,type(num2**10)) #정수형 출력

# 관계연산자
#python에서의 관계연산자는 관계에 대한 정의가 아니라 물어보는 뜻
#때문에 관계연산자의 답은 항상 bool(논리형)인 True과 False로만 출력된다!

num1 = 10
num2 = 15

print(num1>num2,type(num1>num2)) #10이 15보다 크니? => 아니! 크지않아!(False)
print(num1<num2,type(num1<num2)) #10이 15보다 작니? => 어! 작아!(True)
print(num1==100,type(num1==100)) #10이 100과 같니? => 아니! 달라!(False)

#<실습>
#f-string을 사용하여 관계연산자 이해하기!
print(f"{num1}>{num2}: {num1>num2}") # f-string으로 식만들어주고
 #{안에 관계연산자를 넣어 값만 출력하는것}
print(f"{num1}<={num2}: {num1<=num2}")
print(f"{num2}>{num1}: {num2>num1}")
print(f"{num1}!={10}: {num1!=10}")

#관계연산자의 ==,!=는 문자열도 계산가능
print('안녕'=='안녕') #안녕은 안녕과 같기때문에 True
print('안녕'!='안녕') #안녕은 안녕과 다르지않기때문에 False

#논리연산자

# 논리연산자 and
num1 = 10
num2 = 0
print(f"{num1}>10 and {num2}>=0: {num1 > 10 and num2 >=0}") #False반환
#10이 10보다 크다는것은 False 0이 0보다 크거나 같다는것은 True

print(f"{num1}>=4 and {num2}==0: {num1>=4 and num2==0}")
#10이 4보다 크다는것은 True 0은 0인것은 True이기때문에 둘다 True로 True를 반환

print(100>= 50 and 400<20) #False
print(100==100 and 40>20) #True

#논리연산자 or
print(f"{num1}>10 or {num2}>=0: {num1>10 or num2 >=0}")
#10이 10보다 크다는 것은 False이지만 0이 0보다 크거나 같다는것은True이므로 True가
#한개라도 포함이 되어있기때문에 or는 True가 반환
print(100>100 or 0==0) #True

#논리연산자 not : 원래 가지고 있는값의 반대값을 반환함
print(not True)
print(not False)
print(f"not{num1}: {not num1}",type(f"not{num1}: {not num1}"))
#자동적으로 논리형변환이 되어 10은 True인데 not인 반대를 보여달라고 했기때문에 False반환
print(f"not{num1}==10: {not num1==10}")

#삼항 연산자
#3개의 항을 이용
#조건식이 참일때 실행: if조건식
#거짓일때 실행 : else

print("True는 참" if True else "False는 거짓")
#조건식에 True가 입력되어있으므로 참일때 실행되는 왼쪽 실행문이 출력
print("True는 참" if False else "False는 거짓")
#조건식에 False가 입력되었으므르 거짓일때 실행되는 오른쪽 실행문이 출력

print("10은 5보다 큽니다" if 10>5 else "10은 5보다 작습니다")

# <실습1>
#정수를 입력받고 입력받은 정수가 짝수라면 "짝수입니다"출력
#홀수이면 "홀수입니다" 출력

#삼항연산자와 짝수, 홀수구분은 %나머지연산자 활용

#1) 정수입력받기
num= int(input("숫자를 입력해주세요"))

#2)삼항 조건식 작성하기
result="짝수입니다"if num%2==0 else "홀수입니다"
#삼항연산자를 변수안에 넣어 출력하는 방법
# print("짝수입니다"if num%2==0 else"홀수입니다")
#위의 방법처럼 print문에 넣어줄 수 도있음
print(result,type(result))
print("                   ")


#<실습2>
#정수를 입력받고 입력받은 정수가 3의 배수라면 입력받은 정수를 출력하고
#아니라면 '배수가 아닙니다' 출력하기

num1= int(input('숫자를 입력해주세요'))
result2= num1 if num1%3==0 else "3의 배수가 아닙니다"
print(result2)
print("                   ")


#<실습3>
#관계연산자, 삼항 연산자를 활용해서
#정수2개를 입력받고 2개의 숫자의 차이를 절대값으로 출력하는 프로그램만들기
#절대값은 10 -> 10    -10의 절대값은 10

num2 = int(input("첫번째 숫자를 입력해주세요: "))
num3 = int(input("두번째 숫자를 입력해주세요: "))

result3 = num2- num3 if num2>num3 else num2 - num3
print(result3)
print(f"{num2}과 {num3}의 차이는  {result3}입니다")

# 삼항연산자 <개인 실습>

#밴드이름으로 if문 해보기(print문에 바로출력하기)
band1 = input('밴드이름을 입력하세요: ')
result4="수상자 입니다" if band1=='유다빈 밴드' else "수상자가 아닙니다"
print(result4)
print(f"{band1}은(는) 이번 2024어워드 {result4}")

# 대입연산자와 복합대입 연산자

#대입연산자 : =
number = 10
print(number) #일반 대입연산자를 사용했기때문에 number에는 10추출

#복합대입 연산자: +=, -=, *=, **=, /=, //=, %= 등등
number +=10
print(number)#위의 number(10)에 10을 더한다음 다시 변수안에 넣었기때문에 20추출

num6= 50
num6 -= 30
print(num6)

num7 = 100
num7 %=2
print(num7)

num8=100
num8 //=2
print(num8)

num9=10
num9/=3
print(num9,type(num9)) #나누기면 무조건 실수

#복합연산자를 사용할때는 변수명 뒤에 대입연산자를 써줄 필요가없음
#ex) num=+=10(X) num+=10(O)

#컬렉션
"""정수, 실수, 문자열 등 하나로 정해져있는 데이터 타입과는 달리,
여러가지 데이터타입을 묶어서 사용할 수 있는 형태"""

#list

#1)[]대괄호 사용하며 중복값이 허용된다
#2)모든 자료형이 들어간다 = 리스트안에 리스트도 들어갈 수 있음
li1 = [1,2,3,1,2,3]
print(li1) #중복값허용
li1=[1,2,3,1,2,3,"안녕!",20.1,True,[4,5,6]]
print(li1)#문자, 실수, 논리, 리스트까지 리스트안에 전부 들어갈 수 있음

#3) list는 시퀀스 자료형
#리스트는 시퀀스 자료형이기때문에 indexing과 slicing이 가능함
#[indexing]
li2=[1,2,5,345,74,3]
print(li2[0],li2[5],li2[3]) #인덱싱 가능
print(li2[0],type(li2[0])) #리스트안에 저장되어있는 자료형으로 출력됨 'int'
print(li2[0]+li2[5]+li2[3]) #리스트안에 저장된 값이 int이기때문에 +하면 덧셈가능
print(li1[6],type(li1[6])) #문자형이기때문에 자료형 str
print(li1[7],type(li1[7])) #실수형이기때문에 자료형 float
print(li1[8],type(li1[8])) #논리형이기때문에 자료형 bool

#[silcing]
print(li2[0:3]) #슬라이싱 가능
print(li2[0:4],type(li2[0:4])) #슬라이싱 한경우 자료형은 list로 출력
"""인덱싱은 '추출'하는것 이기때문에 하나의 자료형으로 출력이되지만
슬라이싱은 '자르는것'. 큰 빵덩어리를 자른다고 빵이 아닌게 아니기때문에
슬라이싱으로 리스트를 출력한 경우에는 자료형은 리스트로 출력됨"""
print(li2[0:1],type(li2[0:1])) #슬라이싱으로 한개만 가져오더라도 자료형은 리스트임

#이중 list / 2차원 리스트
li3 = [1,2,3,['1','2','3']]
print(li3,type(li3))
print(li3[0],type(li3[0])) #인덱싱 한것이기때문에 int의 자료형으로 출력
print(li3[3],type(li3[3])) #2차원 리스트는 리스트의 한 덩어리로 인덱스번호를 가짐
#애초에 만들어진 자료가 리스트이기때문에 자료형을 뽑아도 리스트라고 추출
print(li3[3][1],type(li3[3][1]))#2차원 리스트안에 있는 자료값을 뽑을때는 리스트인덱스번호를
#먼저 적어준 후 쉼표없이 그 옆에 바로 2차원리스트의 기준 인덱스번호를 입력한다!

#이중 리스트 자료추출 실습>
li4 = [1,2,3,['안녕','반가워']]
print(li4[3][0][0],type(li4[3][0][0]))
#이중리스트에 저장된 자료값에서도 한글자만 추출하고싶다면
#이중리스트번호 -> 이중리스트의 자료값번호-> 이중 리스트의 자료값번호의 인덱스번호


# 컬렉션에서 사용할 수 있는 in, not in연산자
# a in 컬렉션 => a라는 값이 컬렉션 안에 있어?
# a not in => a라는 값이 컬렉션 안에 없어?

print(1 in li4) #리스트안에 1이 있기때문에 컴퓨터가 '응!' 있어! 라고 대답 = (True)
print(100 in li4) #리스트안에 100이 없기때문에 컴퓨터가 '아니!' 없어! 대답 =(False)
print(1 not in li4) #리스트안에 1이 있는데 없냐고 물어봐서 컴퓨터가 '아니!' 있어!= (False)
print(100 not in li4) #리스트안에 100이 없는 없냐고 물어봐서 컴퓨터가 '응!' 없어! 라고 대답=(True)


#리스트에서 사용하는 시퀀스 연산자
#리스트도 시퀀스 연산자이기때문에 시퀀스 연산자의 사용이 가능하다
li5 = [1,2,3]
li6 =[4,5,6]

print(li5+li6,type(li5+li6))#리스트와 리스트를 합쳐준 것이기때문에 하나의 리스안에 리스트의값이 모두 들어간다
print(li5*3,type(li5*3))
print(li5[0]+li6[0],type(li5[0]+li6[0]))
#리스트에서 숫자형 자료형을 인덱스해서 추출해서 연산하면 연산 가능!