# -*- coding: utf-8 -*-
"""데분1_6일차.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19Y--KhWFusjYpy2GYA8fpeBodGbhILc3
"""

#리스트 수정하는법

#리스트 안의 요소에 접근하기 : 인덱스 번호

li1 = [1,3,5,7,"korea",3.14,True] #리스트는 모든 자료형을 허용한다!
print(li1,type(li1))

li2 = [1,2,[1,2],1,1,[1,2,1,1,1]] #리스트는 중복값을 허용한다!
print(li2[5][4],type(li2[5][4]))


#문자열 ->리스트(문자열을 리스트요소로 만들기)
data= 'hello python'
print(data,type(data))
data1= list(data)
print(data1,type(data1)) #원래 문자열이었던 것을 한글자씩 리스트의 값요소로 출력됨. 공백까지!
print(data1[3],type(data1))

data2 = data.split() #data= 'hello python' 일반 문자열을 split()메소드를 통해 data2라는 변수에 넣음
print(data2,type(data2))#단어로 나뉘어진 형태인데 리스트로 출력이 됨
#split(): 문자열 메소드로 ()안에 있는 것을 공백기준으로 잘라서 리스트로 만들어줌
print(data2[1][0],type(data2[1][0])) #split()사용 후 단어별로 인덱스 번호가 부여되고 그 단어 안에서도 인덱스번호가 따로 부여됨. 리스트안의 리스트값 출력하는법과 동일

print()

#<실습>
band = '유다빈 밴드'
band1=list(band)
print(band,type(band1)) #리스트로 출력됨
print(band1[3],type(band1[3])) #공백 출력

band2= band.split()
print(band2,type(band2))
print(band2[1][0],type(band2[1][0]))

#리스트 요소에 접근하기


#리스트 안의 요소에 접근하기 : 인덱스 번호

li1=[10,20,30,40,50,60,70,80]
print(li1,type(li1))

print(li1[4],type(li1[4])) #인덱스번호를 사용했기때문에 int로 출력
print(li1[1:4],type(li1[1:4])) #슬라이싱할때 끝번호는 가지고오지 않기때문에 40까지 출력됨
#인덱스는 추출이기때문에 고유의 자료형이 나오고 슬라이싱은 잘라서 가지고오는 것이기때문에 슬라이싱으로 출력됨

#리스트 수정
li1 = [10,20,30,40,50,60,70,80,90]
print(li1,type(li1))
print(li1[0],type(li1[0])) #인덱스
print(li1[0:3],type(li1[0:3])) #슬라이싱


#인덱스 번호를 활용한 리스트 값 수정
li1[0]=100
print(li1[0],type(li1[0]))
print(li1,type(li1))
li1[8]=900
print(li1,type(li1))

#슬라이싱을 활용하여 리스트 값 수정
li1[0:3]=[1,2,3] #슬라이싱을 활용해서 값을 바꾸고자한다면 무조건 리스트를 사용해야한다
print(li1,type(li1))

li1[::2]=[1,2,3,4,5] #바꾸려는 값과 리스트안의 값의 갯수가 동일해야함. 그렇지 않으면 에러!
print(li1,type(li1))

#리스트에서 사용가능한 함수
li=[1,3,5,7,9]
print(f"li의 길이:{len(li)}")
print(f"li의 최대값:{max(li)}")
print(f"li의 최소값:{min(li)}")
print(f"li의 합계:{sum(li)}")
print(f"li의 평균:{sum(li)/len(li)}") #나누기는 무조건 실수로 출력

#다른 컬렉션에서도 사용가능!

#리스트의 메소드
li=[1,3,5,7,9]
print(li)

#추가 append, insert
#1).append
li.append(10)
print(li) #10이라는 값이 li의 리스트의 맨끝에 추가가 되었음
li.append(11)
print(li)

# li.append(2,4) #에러발생! append는 무조건 값을 한개만 추가할 수 있음

#2)insert
li.insert(1,2) #(인덱스번호, 값)의 형태로 적고 원하는 인덱스 번호에 해당 값을 넣을 수 있음
print(li) #기존 1번 위치에 있던 3이 삭제되는게 아니라 그 뒤로 밀려서 들어감
li.insert(3,4)
print(li)
# li.insert(3,4,5,6) 에러발생! 인덱스도 인덱스번호와 값만 한세트로 들어갈 수 있음! 여러개의 값 전달X


#.extend :리스트와 리스트 연결
li2= [10,20]
li3 = [50,70,90]
print(li2+li3,type(li2+li3)) #시퀀즈 자료형이기때문에 +연산자 사용하여 합쳐져서 출력

print(li2) #+연산자를 사용했을때만 합쳐져서 출력되고 li2원본 자체는 변경되지 않음.

li2.extend(li3)
print(li2)#+연산자를 사용했을때와 결과는 같아보이지만 extend()메소드를 사용하면 원본자체가 달라짐

#.remove(값) / pop(idex)
print(li2,type(li2))
li2.remove(50)
print(li2) #remove를 거친 후 50이 삭제가 되어 출력

li3 =[1,2,3,4,1,3,5,7]
print(li3)
li3.remove(1)
print(li3) #리스트안에 있는 수 중에 1이 중복값. remove안에 중복값이 있는 수를 입력하면
#해당 리스트 기준 맨 앞에 있는 수만 삭제함.  [2, 3, 4, 1, 3, 5, 7]로 출력
li3.remove(1)
print(li3) #[2, 3, 4, 3, 5, 7]로 출력. 두번째 있던 1이 사라짐 (리스트안에 1이 없는 상태)
# li3.remove(1)
# print(li3) 에러발생! 리스트안에 지우려는 값이 없기때문

print()

#pop(idex)
li2.pop(0)
print(li2) #0번째 인덱스 번호에위치해있던 10이 삭제되어서 출력!

li3 =[1,2,3,4,1,3,5,7]
li3.pop(2)
print(li3) #인덱스번호 2번째에 있던 3이 삭제되어서 출력
# li3.pop(11) # pop index out of range 해당 리스트에 11번인 인덱스번호가 없기때문에 에러!
li3.pop() #메소드 pop()안에 인덱스 번호 지정해주지않으면 맨 끝값이 삭제됨!
print(li3)

#리스트의 메소드

#정렬 .sort()  /  .sort(reverse=True) / reverse()
li1 = [1,3,2,5,7,5,6,9,10,11]
print(li1,type(li1))

li1.sort() #이미 .sort앞에 객체를 지정해주었기때문에 괄호안에 아무것도 적지 않음
print(li1) #오름차순으로 정렬되어서 나옴

li1.sort(reverse=True) #.sort()안에 reverse=True라고 적게되면 내림차순으로 정렬하겠다는 뜻!
print(li1) #True를 False로 적으면 오름차순으로 나옴

li2 = ["a","b","c"]
li2.sort(reverse=True)
print(li2) #내림차순으로 c부터 출력!
li2.sort()
print(li2)#다시 오름차순으로 a부터 출력!

li2 = [1,2,3,"a","b","c"]
# li2.sort()
# print(li2)
# 객체.sort() / 객체.sort(reverse=True)는 숫자와 문자를 함께 사용할 수 없음. 문자는 문자끼리, 숫자는 숫자끼리만 사용!

#reverse() : 역순으로 정렬
li2.reverse() #reverse는 그냥 단순 역순출력이기때문에 문자+숫자 조합 사용가능
print(li2) #역순으로 c부터 출력됨


#리스트 전체 삭제. clear()  / del
li2.clear()
print(li2) #리스트안에 있는 요소값 전부 삭제 #빈 리스트를 만드는 메소드!

#del:리스트 자체를 삭제(del은 변수 삭제할때도 사용, 저장공간 삭제할때도 사용->저장공간 자체를 없애줌)
del li2
# print(li2)# not define 으로 출력! del로 리스트를 삭제해주었기때문!

#튜플의 생성
tu1 = 1,2,3,4
print(tu1,type(tu2)) #튜플의 패킹
tu2 = 10,
print(tu2,type(tu2))

#비어있는 튜플
tu3=()
print(tu3,type(tu3))
tu4=tuple()
print(tu4,type(tu4))

#튜플의 요소 접근하기
tu1=(10,20,30,10,10,'a','b')
print(tu1[0],type(tu1[0]))
print(tu1[:4],type(tu1[:4]))

#튜플의 요소 수정
# tu1[0]=12 #튜플은 수정이 불가함!
# print(tu1)

#튜플을 수정하기위해서는 튜플을 다른 자료형으로 형변환 해주어함
#tuple => list
tu1=list(tu1)
print(tu1,type(tu1)) #튜플에 대한 요소는 그대로 가지면서 자료형이 리스트로 변환!

tu1[0]=100 #리스트는 변경이 가능하기때문에 인덱스로 요소 수정가능!
print(tu1)

tu1=tuple(tu1)
print(tu1,type(tu1)) #리스트로 형변환 한 후에 값을 수정하고 다시 tuple()함수를 이용하여
#tuple로 변환하면 튜플의 값을 수정할 수 있음!

#튜플의 메소드

tu=(1,2,3,4,5,1,2,4,1,2,3,1,2)
print(tu,type(tu))
print(tu.count(1)) #count(값): 튜플안에 해당값이 몇개나 있는지 갯수로 보여줌
print(tu.index(3),type(tu.index(3))) #index안에 있는 해당 값이 객체안에서 인덱스 몇번에 위치에 있는건지 반환해줌
print(tu.index(3),type(tu.index(3))) #두번출력해도 맨 처음거 출력
print(tu.index(1,5,10))
#index 메소드 사용할때 안에 값을 3개를 입력하게되면
#(찾을값, 시작할 인덱스, 종료할 인덱스)로 해당 찾을 값의 범위를 한정
print(tu.index(3,2,7))


#튜플에서 append / insert / remove, pop / sort 사용불가!!!
#튜플에서 값은 수정이 안되는데 append와 insert,remove,pop은 값을 추가 및 삭제 하여 수정하는 것이기때문에
#튜플에서 사용이 불가함. 'tuple' object has no attribute 'insert'
#튜플에서 값을 추가하고싶다면 리스트로 형변환 한 후에 값 추가하기!
del tu #del은 사용가능함. 튜플의 요소를 삭제하는것은 수정에 해당하지만 튜플자체삭제는 해당이 안되기때문

#튜플의 함수
tu=(1,2,3,4,5,1,2,4,1,2,3,1,2)
print(f"tu의 길이:{len(tu)}")
print(f"tu의 최대값:{max(tu)}")
print(f"tu의 최소값:{min(tu)}")
print(f"tu의 합계:{sum(tu)}")
print(f"tu의 평균:{sum(tu)/len(tu)}")

#튜플의 함수는 리스트와 동일하게 사용가능

#세트의 메소드
set1 = {'사과','참외','파인애플','멜론'}
print(set1,type(set1))

#값 추가하기 .add
set1.add('포도')
print(set1,type(set1)) #추가되는 순서는 상관없음. 그냥 포도라는 값이 추가가되면 됨
set1.add('딸기')
print(set1)
set1.add('포도') #이미 포도가 있는데 추가한다고 해서 에러나지 않음. 코드무시

#값 삭제하기 .remove() / discard() / pop()
set1.remove('포도')
print(set1) #포도 삭제
# set1.remove('수박') #수박은 삭제가 되지 않고 에러가남. 세트에 수박이라는 값이 없기때문

set1.discard('수박') #세트에 없는 값을 입력해도 에러가 나지않음
print(set1) #코드무시가 되어 출력 됨

set1.pop()
print(set1) #아무값이나 1개 삭제가 됨
set1.pop()
print(set1)

# set2={'만두', '피자', '치즈', '김치'}
# set1.extend(set2)
#set에서 extend 사용 불가

#세트의 집합연산

#세트는 다른 컬렉션들과는 다르게 집합연산이 가능함

se1 = {1,2,3,4,5}
se2 = {3,4,5,6,7}

#교집합
#intersection  &
print(se1 & se2,type(se1 & se2))
se1.intersection(se2)
print(se1.intersection(se2)) #print()문 안에서도 바로 사용가능

#합집합
#union  |
print(se1.union(se2)) #중복값이 제외된 다음 합집합으로 합쳐짐
se1.union(se2)
print(se1 | se2)

#차집합
#difference  -
print(se1 - se2) #se1기준에서 se2에 없는 값을 찾아주는것
#때문에 차집합은 앞뒤에 어떤 세트를 먼저 적느냐에 따라 값이 달라질 수 있음
print(se1.difference(se2))

print(se2 - se1)
print(se2.difference(se1))

#세트는 합집합, 교집합, 차집합

set1={1,2,3,4,5}
set2={1,2,5,7,8}

print(set1.intersection(set2)) #교집합
print(set1.union(set2))
print(set1.difference(set2))